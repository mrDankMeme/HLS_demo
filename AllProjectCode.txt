// App/Domain/Models/VideoRecommendation.swift
import Foundation

public struct VideoRecommendation: Identifiable, Decodable {
    public var id: Int { video_id }
    public let video_id: Int
    public let title: String
    public let preview_image: String?
    public let duration_sec: Int?
    public let numbers_views: Int?
    public let free: Bool?                 // ← добавили
    public let time_not_reg: Int?          // ← добавили (null → nil)
    public let has_access: Bool?           // (на будущее)
}
import SwiftUI
import AVFoundation

struct SingleVideoView: View {
    @StateObject private var vm = SingleVideoViewModel()
    /// nil → автоматически найдём первый полностью открытый ролик
    let videoID: Int?

    var body: some View {
        VStack {
            PlayerViewRepresentable(player: vm.player, showsControls: true, fill: true)
                .task {
                    configureAudioSessionForPlayback()
                    if let id = videoID {
                        vm.loadAndPlay(videoID: id, mute: true)
                    } else {
                        await vm.loadFirstFreeAndPlay(mute: true)
                    }
                }

            HStack {
                Button(vm.isPlaying ? "Pause" : "Play") {
                    if vm.isPlaying {
                        vm.pause()
                    } else {
                        vm.player.playImmediately(atRate: 1.0)
                        vm.isPlaying = true
                    }
                }
                .buttonStyle(.bordered)

                Button(vm.player.isMuted ? "Unmute" : "Mute") {
                    vm.player.isMuted.toggle()
                }
                .buttonStyle(.bordered)
            }
            .padding()
        }
        .navigationTitle(videoID != nil ? "HLS #\(videoID!)" : "HLS (first free)")
    }
}
import SwiftUI
import UIKit
import AVKit
import AVFoundation

// MARK: - Snapping (center)
final class SnappingFlowLayout: UICollectionViewFlowLayout {
    override func targetContentOffset(forProposedContentOffset proposed: CGPoint,
                                      withScrollingVelocity velocity: CGPoint) -> CGPoint {
        guard let cv = collectionView else { return proposed }
        let midY = proposed.y + cv.bounds.height/2
        let rect = CGRect(x: 0, y: proposed.y, width: cv.bounds.width, height: cv.bounds.height)
        guard let attrs = layoutAttributesForElements(in: rect) else { return proposed }

        var closest: UICollectionViewLayoutAttributes?
        var minDist = CGFloat.greatestFiniteMagnitude
        for a in attrs where a.representedElementCategory == .cell {
            let d = abs(a.center.y - midY)
            if d < minDist { minDist = d; closest = a }
        }
        guard let target = closest else { return proposed }
        return CGPoint(x: proposed.x, y: target.center.y - cv.bounds.height/2)
    }
}

// MARK: - Cell (серый фон + уголки)
final class ReelCell: UICollectionViewCell {
    static let reuseID = "ReelCell"
    private let titleLabel = UILabel()

    override init(frame: CGRect) {
        super.init(frame: frame)
        contentView.clipsToBounds = true
        contentView.layer.cornerRadius = 16
        contentView.backgroundColor = UIColor(white: 0.12, alpha: 1.0)
        contentView.layer.borderColor = UIColor(white: 1, alpha: 0.08).cgColor
        contentView.layer.borderWidth = 1

        titleLabel.textColor = .white
        titleLabel.font = .boldSystemFont(ofSize: 18)
        titleLabel.numberOfLines = 2
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        titleLabel.layer.shadowColor = UIColor.black.cgColor
        titleLabel.layer.shadowOpacity = 0.65
        titleLabel.layer.shadowRadius = 3

        contentView.addSubview(titleLabel)
        NSLayoutConstraint.activate([
            titleLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 16),
            titleLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -16),
            titleLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -24)
        ])
    }
    required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }
    func configure(title: String) { titleLabel.text = title }
}

// MARK: - VC
final class ReelsPagerViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate {
    private let layout = SnappingFlowLayout()
    private var collectionView: UICollectionView!
    private var items: [VideoRecommendation] = []
    private var activeID: Int?
    private var currentCenteredIndex: Int?
    private var didSetInitial = false
    private var lastItemsSignature: String?

    var onActiveIndexChanged: ((Int) -> Void)?
    var sharedPlayer: AVPlayer! { didSet { playerVC.player = sharedPlayer } }

    /// Один AVPlayerViewController с системными контролами. Его view «кочует» между ячейками.
    private let playerVC: AVPlayerViewController = {
        let vc = AVPlayerViewController()
        vc.showsPlaybackControls = true
        vc.videoGravity = .resizeAspectFill
        vc.allowsPictureInPicturePlayback = true
        vc.canStartPictureInPictureAutomaticallyFromInline = true
        vc.updatesNowPlayingInfoCenter = false
        return vc
    }()
    private weak var currentHostCell: ReelCell?

    private let hPad: CGFloat = 24
    private let vPad: CGFloat = 24

    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .systemYellow

        layout.scrollDirection = .vertical
        layout.minimumLineSpacing = 16
        layout.sectionInset = .init(top: vPad, left: hPad, bottom: vPad, right: hPad)

        collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
        collectionView.translatesAutoresizingMaskIntoConstraints = false
        collectionView.backgroundColor = .systemYellow
        collectionView.decelerationRate = .fast
        collectionView.showsVerticalScrollIndicator = false
        collectionView.register(ReelCell.self, forCellWithReuseIdentifier: ReelCell.reuseID)
        collectionView.dataSource = self
        collectionView.delegate = self

        view.addSubview(collectionView)
        NSLayoutConstraint.activate([
            collectionView.topAnchor.constraint(equalTo: view.topAnchor),
            collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        layout.itemSize = CGSize(width: view.bounds.width - 2*hPad,
                                 height: view.bounds.height - 2*vPad)
        playerVC.view.frame = currentHostCell?.contentView.bounds ?? .zero
    }

    // MARK: API из Representable

    func setItems(_ newItems: [VideoRecommendation]) {
        let sig = newItems.map { "\($0.video_id)" }.joined(separator: ",")
        guard sig != lastItemsSignature else { return }
        lastItemsSignature = sig

        items = newItems
        collectionView.reloadData()

        guard !items.isEmpty else { return }
        if !didSetInitial {
            didSetInitial = true
            // Центрируемся на 0, РАНО приклеиваем плейер к центральной ячейке (без ожидания SwiftUI)
            DispatchQueue.main.async { [weak self] in
                guard let self else { return }
                self.scrollTo(index: 0, animated: false)
                self.collectionView.layoutIfNeeded()
                if let cell = self.collectionView.cellForItem(at: IndexPath(item: 0, section: 0)) as? ReelCell {
                    self.attachPlayer(to: cell)
                }
                self.notifyActive(index: 0)
            }
        }
    }

    func setActiveVideoID(_ id: Int?) {
        activeID = id
        guard let id,
              let cell = visibleCell(forVideoID: id) else { return }
        attachPlayer(to: cell) // если активная видима — сразу показываем видео и контролы
    }

    // MARK: DataSource

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { items.count }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ReelCell.reuseID, for: indexPath) as! ReelCell
        cell.configure(title: items[indexPath.item].title)
        return cell
    }

    func collectionView(_ collectionView: UICollectionView, willDisplay cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {
        guard indexPath.item < items.count else { return }
        let it = items[indexPath.item]
        if it.video_id == activeID, let rc = cell as? ReelCell { attachPlayer(to: rc) }
    }

    func collectionView(_ collectionView: UICollectionView, didEndDisplaying cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {
        if currentHostCell === (cell as? ReelCell) { detachPlayer() }
    }

    // MARK: Снап + активация

    func scrollViewWillEndDragging(_ scrollView: UIScrollView,
                                   withVelocity velocity: CGPoint,
                                   targetContentOffset: UnsafeMutablePointer<CGPoint>) {
        guard !items.isEmpty else { return }
        let midY = scrollView.contentOffset.y + scrollView.bounds.height/2
        let visible = collectionView.indexPathsForVisibleItems
        let currentIndex: Int = {
            let t = visible.min {
                let f1 = collectionView.layoutAttributesForItem(at: $0)?.frame ?? .zero
                let f2 = collectionView.layoutAttributesForItem(at: $1)?.frame ?? .zero
                return abs(f1.midY - midY) < abs(f2.midY - midY)
            }
            return t?.item ?? 0
        }()

        var targetIndex = currentIndex
        let threshold: CGFloat = 8

        if abs(velocity.y) > 0.08 {
            targetIndex = currentIndex + (velocity.y > 0 ? 1 : -1)
        } else if let frame = collectionView.layoutAttributesForItem(at: IndexPath(item: currentIndex, section: 0))?.frame {
            let delta = frame.midY - midY
            if      delta < -threshold { targetIndex = min(currentIndex + 1, items.count - 1) }
            else if delta >  threshold { targetIndex = max(currentIndex - 1, 0) }
        }

        targetIndex = max(0, min(items.count - 1, targetIndex))
        if let attr = collectionView.layoutAttributesForItem(at: IndexPath(item: targetIndex, section: 0)) {
            targetContentOffset.pointee.y = attr.center.y - scrollView.bounds.height/2
            notifyActive(index: targetIndex)                 // сразу дергаем VM
            if let cell = collectionView.cellForItem(at: IndexPath(item: targetIndex, section: 0)) as? ReelCell {
                attachPlayer(to: cell)                       // и сразу приклеиваем плеер
            }
        }
    }

    func scrollViewDidScroll(_ scrollView: UIScrollView) { updateActiveIfNeeded(force: false) }
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) { updateActiveIfNeeded(force: true) }
    func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
        if !decelerate { updateActiveIfNeeded(force: true) }
    }

    private func updateActiveIfNeeded(force: Bool) {
        guard !items.isEmpty else { return }
        let center = CGPoint(x: collectionView.bounds.midX,
                             y: collectionView.contentOffset.y + collectionView.bounds.midY)
        let idx: Int? = {
            if let ip = collectionView.indexPathForItem(at: center) { return ip.item }
            let vis = collectionView.indexPathsForVisibleItems
            let t = vis.min {
                let f1 = collectionView.layoutAttributesForItem(at: $0)?.frame ?? .zero
                let f2 = collectionView.layoutAttributesForItem(at: $1)?.frame ?? .zero
                return abs(f1.midY - center.y) < abs(f2.midY - center.y)
            }
            return t?.item
        }()
        guard let index = idx else { return }
        if force || currentCenteredIndex != index {
            currentCenteredIndex = index
            notifyActive(index: index)
            if let cell = collectionView.cellForItem(at: IndexPath(item: index, section: 0)) as? ReelCell {
                attachPlayer(to: cell)
            }
        }
    }

    private func notifyActive(index: Int) { onActiveIndexChanged?(index) }
    private func scrollTo(index: Int, animated: Bool) {
        collectionView.scrollToItem(at: IndexPath(item: index, section: 0), at: .centeredVertically, animated: animated)
    }

    // MARK: Работа с player view

    private func attachPlayer(to cell: ReelCell) {
        guard currentHostCell !== cell else { return }
        detachPlayer()

        addChild(playerVC)
        playerVC.view.frame = cell.contentView.bounds
        playerVC.view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        cell.contentView.insertSubview(playerVC.view, at: 0)      // под заголовок
        playerVC.didMove(toParent: self)
        currentHostCell = cell
    }

    private func detachPlayer() {
        guard let host = currentHostCell else { return }
        playerVC.willMove(toParent: nil)
        playerVC.view.removeFromSuperview()
        playerVC.removeFromParent()
        currentHostCell = nil
    }

    private func visibleCell(forVideoID id: Int) -> ReelCell? {
        for c in collectionView.visibleCells {
            guard let idx = collectionView.indexPath(for: c)?.item else { continue }
            if items[idx].video_id == id { return c as? ReelCell }
        }
        return nil
    }
}

// MARK: - SwiftUI wrapper
struct ReelsPagerRepresentable: UIViewControllerRepresentable {
    let items: [VideoRecommendation]
    let activeID: Int?
    let player: AVPlayer
    let onActiveIndexChanged: (Int) -> Void

    func makeUIViewController(context: Context) -> ReelsPagerViewController {
        let vc = ReelsPagerViewController()
        vc.sharedPlayer = player
        vc.onActiveIndexChanged = onActiveIndexChanged
        return vc
    }

    func updateUIViewController(_ ui: ReelsPagerViewController, context: Context) {
        ui.sharedPlayer = player
        ui.setItems(items)
        ui.setActiveVideoID(activeID)
    }
}
import Foundation
import Combine
import AVFoundation

@MainActor
final class SingleVideoViewModel: ObservableObject {
    @Published var isPlaying = false
    let player = AVPlayer()

    private let repo: VideoRepository = DefaultVideoRepository(client: DefaultHTTPClient())

    private var itemCancellables = Set<AnyCancellable>()
    private var timeObserver: Any?
    private var userPaused = false          // чтобы не ломать осознанную паузу пользователя

    deinit {
        if let obs = timeObserver { player.removeTimeObserver(obs) }
        NotificationCenter.default.removeObserver(self)
        itemCancellables.removeAll()
    }

    // MARK: - Public

    func loadAndPlay(videoID: Int, mute: Bool = true) {
        userPaused = false

        let url   = InteresnoAPI.hlsPlaylistURL(videoID: videoID)
        let asset = AVURLAsset(url: url)
        let item  = AVPlayerItem(asset: asset)

        // Анти-столлы/буфер/битрейт
        player.automaticallyWaitsToMinimizeStalling = false
        item.preferredForwardBufferDuration = 0.8
        player.replaceCurrentItem(with: item)
        player.currentItem?.preferredPeakBitRate = 1_200_000
        player.preventsDisplaySleepDuringVideoPlayback = true
        player.allowsExternalPlayback = false
        player.isMuted = mute

        // Первая попытка — если рано, Combine добьёт.
        player.playImmediately(atRate: 1.0)
        isPlaying = true

        attachItemObservers(for: item)
        attachDiagnosticsIfNeeded()
    }

    func loadFirstFreeAndPlay(mute: Bool = true) async {
        do {
            let items = try await repo.fetchRecommendations(offset: 0, limit: 20)
            if let v = items.first(where: { ($0.free ?? false) && $0.time_not_reg == nil }) {
                loadAndPlay(videoID: v.video_id, mute: mute)
            } else if let any = items.first {
                loadAndPlay(videoID: any.video_id, mute: mute)
            }
        } catch {
            debugPrint("fetch recommendations error:", error.localizedDescription)
        }
    }

    func pause() {
        userPaused = true
        player.pause()
        isPlaying = false
    }

    // MARK: - Private

    private func attachItemObservers(for item: AVPlayerItem) {
        itemCancellables.removeAll()

        // Автоплей когда готов
        item.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                guard let self else { return }
                if status == .readyToPlay, !self.userPaused {
                    self.player.playImmediately(atRate: 1.0)
                    self.isPlaying = true
                }
            }
            .store(in: &itemCancellables)

        // Автоплей когда буфер «держит»
        item.publisher(for: \.isPlaybackLikelyToKeepUp)
            .removeDuplicates()
            .receive(on: RunLoop.main)
            .sink { [weak self] keepUp in
                guard let self, keepUp, !self.userPaused else { return }
                self.player.playImmediately(atRate: 1.0)
                self.isPlaying = true
            }
            .store(in: &itemCancellables)

        // Репит: когда дошли до конца — перематываем к началу и сразу play
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else { return }
                guard !self.userPaused else { return }          // пользователь на паузе — не автозапускаем
                let zero = CMTime.zero
                self.player.seek(to: zero, toleranceBefore: .zero, toleranceAfter: .zero) { _ in
                    self.player.playImmediately(atRate: 1.0)
                    self.isPlaying = true
                }
            }
            .store(in: &itemCancellables)

        // На случай внешних стопов
        NotificationCenter.default.publisher(for: .AVPlayerItemPlaybackStalled, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self, !self.userPaused else { return }
                self.player.playImmediately(atRate: 1.0)
                self.isPlaying = true
            }
            .store(in: &itemCancellables)
    }

    private func attachDiagnosticsIfNeeded() {
        guard timeObserver == nil else { return }
        timeObserver = player.addPeriodicTimeObserver(
            forInterval: CMTime(seconds: 0.5, preferredTimescale: 600),
            queue: .main
        ) { [weak self] t in
            guard let self else { return }
            let status: String
            switch self.player.timeControlStatus {
            case .paused: status = "paused"
            case .waitingToPlayAtSpecifiedRate: status = "waiting"
            case .playing: status = "playing"
            @unknown default: status = "unknown"
            }
            let reason = self.player.reasonForWaitingToPlay?.rawValue ?? "nil"
            debugPrint(String(format: "⏱ %.2f s, status=%@, reason=%@", t.seconds, status, reason))
        }
    }
}
// App/App.swift
import SwiftUI

@main
struct DemoApp: App {
    var body: some Scene {
        WindowGroup {
            NavigationStack {
                // Вариант для быстрой проверки гипотезы:
                // nil → автоматически найдём и запустим первый полностью открытый ролик
                //SingleVideoView(videoID: nil)
                ReelsView()
                // или, если хочешь принудительно:
                // SingleVideoView(videoID: 52)
            }
        }
    }
}
// App/Infrastructure/Repositories/VideoRepository.swift
import Foundation

public protocol VideoRepository {
    func fetchRecommendations(offset: Int, limit: Int) async throws -> [VideoRecommendation]
}

public final class DefaultVideoRepository: VideoRepository {
    private let client: HTTPClient
    public init(client: HTTPClient) { self.client = client }

    private struct RecResponse: Decodable {
        let items: [VideoRecommendation]
    }

    public func fetchRecommendations(offset: Int, limit: Int) async throws -> [VideoRecommendation] {
        let url = InteresnoAPI.recommendationsURL(offset: offset, limit: limit)
        let (data, http) = try await client.get(url: url)
        guard (200..<300).contains(http.statusCode) else { throw URLError(.badServerResponse) }
        return try JSONDecoder().decode(RecResponse.self, from: data).items
    }
}
// App/Core/Networking/HTTPClient.swift
import Foundation

public protocol HTTPClient {
    func get(url: URL) async throws -> (Data, HTTPURLResponse)
}

public final class DefaultHTTPClient: HTTPClient {
    private let session: URLSession
    public init(session: URLSession = .shared) { self.session = session }

    public func get(url: URL) async throws -> (Data, HTTPURLResponse) {
        let (data, resp) = try await session.data(from: url)
        guard let http = resp as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        return (data, http)
    }
}
import Foundation
import Combine
import AVFoundation

@MainActor
final class ReelsViewModel: ObservableObject {
    @Published var items: [VideoRecommendation] = []
    @Published var activeVideoID: Int?

    let player = AVPlayer()

    private let repo: VideoRepository = DefaultVideoRepository(client: DefaultHTTPClient())
    private var itemCancellables = Set<AnyCancellable>()
    private var timeObserver: Any?
    private var lastPlayedID: Int?

    deinit {
        if let obs = timeObserver { player.removeTimeObserver(obs) }
        NotificationCenter.default.removeObserver(self)
        itemCancellables.removeAll()
    }

    func load() async {
        do {
            let recs = try await repo.fetchRecommendations(offset: 0, limit: 30)
            self.items = recs
            if let first = recs.first {
                setActive(videoID: first.video_id)
            }
        } catch { print("reels load error:", error) }
    }

    func setActive(videoID: Int, mute: Bool = true) {
        guard activeVideoID != videoID else { return }
        activeVideoID = videoID
        play(videoID: videoID, mute: mute)
    }

    func play(videoID: Int, mute: Bool = true) {
        guard lastPlayedID != videoID else { return }
        lastPlayedID = videoID

        let url   = InteresnoAPI.hlsPlaylistURL(videoID: videoID)
        let asset = AVURLAsset(url: url)
        let item  = AVPlayerItem(asset: asset)

        player.automaticallyWaitsToMinimizeStalling = false
        item.preferredForwardBufferDuration = 0.8

        player.replaceCurrentItem(with: item)
        player.currentItem?.preferredPeakBitRate = 1_200_000
        player.preventsDisplaySleepDuringVideoPlayback = true
        player.allowsExternalPlayback = false
        player.isMuted = mute

        player.playImmediately(atRate: 1.0)

        attachItemAutoplayObservers(for: item)
        attachDiagnosticsIfNeeded()
        attachLoop(for: item)
    }

    private func attachLoop(for item: AVPlayerItem) {
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else { return }
                self.player.seek(to: .zero, toleranceBefore: .zero, toleranceAfter: .zero) { _ in
                    self.player.playImmediately(atRate: 1.0)
                }
            }
            .store(in: &itemCancellables)
    }

    private func attachItemAutoplayObservers(for item: AVPlayerItem) {
        itemCancellables.removeAll()

        item.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] st in
                guard let self else { return }
                if st == .readyToPlay { self.player.playImmediately(atRate: 1.0) }
            }.store(in: &itemCancellables)

        item.publisher(for: \.isPlaybackLikelyToKeepUp)
            .removeDuplicates()
            .receive(on: RunLoop.main)
            .sink { [weak self] keepUp in
                guard let self, keepUp else { return }
                self.player.playImmediately(atRate: 1.0)
            }.store(in: &itemCancellables)

        NotificationCenter.default.publisher(for: .AVPlayerItemPlaybackStalled, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in self?.player.playImmediately(atRate: 1.0) }
            .store(in: &itemCancellables)
    }

    private func attachDiagnosticsIfNeeded() {
        guard timeObserver == nil else { return }
        timeObserver = player.addPeriodicTimeObserver(forInterval: CMTime(seconds: 0.5, preferredTimescale: 600),
                                                      queue: .main) { [weak self] t in
            guard let self else { return }
            let status: String
            switch self.player.timeControlStatus {
            case .paused: status = "paused"
            case .waitingToPlayAtSpecifiedRate: status = "waiting"
            case .playing: status = "playing"
            @unknown default: status = "unknown"
            }
            let reason = self.player.reasonForWaitingToPlay?.rawValue ?? "nil"
            debugPrint(String(format: "reels ⏱ %.2f s, status=%@, reason=%@", t.seconds, status, reason))
        }
    }
}
import SwiftUI
import AVFAudio

struct ReelsView: View {
    @StateObject private var vm = ReelsViewModel()

    var body: some View {
        ReelsPagerRepresentable(
            items: vm.items,
            activeID: vm.activeVideoID,
            player: vm.player,
            onActiveIndexChanged: { index in
                guard index >= 0, index < vm.items.count else { return }
                vm.setActive(videoID: vm.items[index].video_id, mute: true)
            }
        )
        .ignoresSafeArea()
        .task {
            configureAudioSessionForPlayback()
            await vm.load()
        }
        .navigationTitle("Reels")
    }
}

import SwiftUI
import AVKit
import AVFAudio

final class AutoplayPlayerViewController: AVPlayerViewController {
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        // На экране? Ещё раз дожмём автоплей.
        player?.playImmediately(atRate: 1.0)
    }
}

struct PlayerViewRepresentable: UIViewControllerRepresentable {
    let player: AVPlayer
    var showsControls: Bool = true
    var fill: Bool = true

    func makeUIViewController(context: Context) -> AVPlayerViewController {
        let vc = AutoplayPlayerViewController()
        vc.player = player
        vc.showsPlaybackControls = showsControls
        vc.videoGravity = fill ? .resizeAspectFill : .resizeAspect
        vc.allowsPictureInPicturePlayback = true
        vc.canStartPictureInPictureAutomaticallyFromInline = true
        vc.updatesNowPlayingInfoCenter = false
        return vc
    }

    func updateUIViewController(_ ui: AVPlayerViewController, context: Context) {
        if ui.player !== player { ui.player = player }
    }
}

func configureAudioSessionForPlayback() {
    do {
        try AVAudioSession.sharedInstance().setCategory(.playback, mode: .moviePlayback, options: [.mixWithOthers])
        try AVAudioSession.sharedInstance().setActive(true)
    } catch {
        print("AudioSession error:", error)
    }
}
// App/Infrastructure/API/InteresnoAPI.swift
import Foundation

public enum InteresnoAPI {
    public static let base = URL(string: "https://interesnoitochka.ru/api/v1")!

    public static func hlsPlaylistURL(videoID: Int) -> URL {
        base.appendingPathComponent("videos/video/\(videoID)/hls/playlist.m3u8")
    }

    public static func recommendationsURL(offset: Int = 0, limit: Int = 20) -> URL {
        var comps = URLComponents(url: base.appendingPathComponent("videos/recommendations"),
                                  resolvingAgainstBaseURL: false)!
        comps.queryItems = [
            .init(name: "offset", value: String(offset)),
            .init(name: "limit", value: String(limit)),
            .init(name: "category", value: "shorts"),
            .init(name: "date_filter_type", value: "created"),
            .init(name: "sort_by", value: "date_created"),
            .init(name: "sort_order", value: "desc")
        ]
        return comps.url!
    }
}
