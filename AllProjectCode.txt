// App/Domain/Models/VideoRecommendation.swift
import Foundation

public struct VideoRecommendation: Identifiable, Decodable {
    public var id: Int { video_id }
    public let video_id: Int
    public let title: String
    public let preview_image: String?
    public let duration_sec: Int?
    public let numbers_views: Int?
    public let free: Bool?                 // ← добавили
    public let time_not_reg: Int?          // ← добавили (null → nil)
    public let has_access: Bool?           // (на будущее)
}
import SwiftUI
import AVFoundation

struct SingleVideoView: View {
    @StateObject private var vm = SingleVideoViewModel()
    /// nil → автоматически найдём первый полностью открытый ролик
    let videoID: Int?

    var body: some View {
        VStack {
            PlayerViewRepresentable(player: vm.player, showsControls: true, fill: true)
                .task {
                    configureAudioSessionForPlayback()
                    if let id = videoID {
                        vm.loadAndPlay(videoID: id, mute: true)
                    } else {
                        await vm.loadFirstFreeAndPlay(mute: true)
                    }
                }

            HStack {
                Button(vm.isPlaying ? "Pause" : "Play") {
                    if vm.isPlaying {
                        vm.pause()
                    } else {
                        vm.player.playImmediately(atRate: 1.0)
                        vm.isPlaying = true
                    }
                }
                .buttonStyle(.bordered)

                Button(vm.player.isMuted ? "Unmute" : "Mute") {
                    vm.player.isMuted.toggle()
                }
                .buttonStyle(.bordered)
            }
            .padding()
        }
        .navigationTitle(videoID != nil ? "HLS #\(videoID!)" : "HLS (first free)")
    }
}
import Foundation
import Combine
import AVFoundation

@MainActor
final class SingleVideoViewModel: ObservableObject {
    @Published var isPlaying = false
    let player = AVPlayer()

    private let repo: VideoRepository = DefaultVideoRepository(client: DefaultHTTPClient())

    private var itemCancellables = Set<AnyCancellable>()
    private var timeObserver: Any?
    private var userPaused = false          // чтобы не ломать осознанную паузу пользователя

    deinit {
        if let obs = timeObserver { player.removeTimeObserver(obs) }
        NotificationCenter.default.removeObserver(self)
        itemCancellables.removeAll()
    }

    // MARK: - Public

    func loadAndPlay(videoID: Int, mute: Bool = true) {
        userPaused = false

        let url   = InteresnoAPI.hlsPlaylistURL(videoID: videoID)
        let asset = AVURLAsset(url: url)
        let item  = AVPlayerItem(asset: asset)

        // Анти-столлы/буфер/битрейт
        player.automaticallyWaitsToMinimizeStalling = false
        item.preferredForwardBufferDuration = 0.8
        player.replaceCurrentItem(with: item)
        player.currentItem?.preferredPeakBitRate = 1_200_000
        player.preventsDisplaySleepDuringVideoPlayback = true
        player.allowsExternalPlayback = false
        player.isMuted = mute

        // Первая попытка — если рано, Combine добьёт.
        player.playImmediately(atRate: 1.0)
        isPlaying = true

        attachItemObservers(for: item)
        attachDiagnosticsIfNeeded()
    }

    func loadFirstFreeAndPlay(mute: Bool = true) async {
        do {
            let items = try await repo.fetchRecommendations(offset: 0, limit: 20)
            if let v = items.first(where: { ($0.free ?? false) && $0.time_not_reg == nil }) {
                loadAndPlay(videoID: v.video_id, mute: mute)
            } else if let any = items.first {
                loadAndPlay(videoID: any.video_id, mute: mute)
            }
        } catch {
            debugPrint("fetch recommendations error:", error.localizedDescription)
        }
    }

    func pause() {
        userPaused = true
        player.pause()
        isPlaying = false
    }

    // MARK: - Private

    private func attachItemObservers(for item: AVPlayerItem) {
        itemCancellables.removeAll()

        // Автоплей когда готов
        item.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                guard let self else { return }
                if status == .readyToPlay, !self.userPaused {
                    self.player.playImmediately(atRate: 1.0)
                    self.isPlaying = true
                }
            }
            .store(in: &itemCancellables)

        // Автоплей когда буфер «держит»
        item.publisher(for: \.isPlaybackLikelyToKeepUp)
            .removeDuplicates()
            .receive(on: RunLoop.main)
            .sink { [weak self] keepUp in
                guard let self, keepUp, !self.userPaused else { return }
                self.player.playImmediately(atRate: 1.0)
                self.isPlaying = true
            }
            .store(in: &itemCancellables)

        // Репит: когда дошли до конца — перематываем к началу и сразу play
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else { return }
                guard !self.userPaused else { return }          // пользователь на паузе — не автозапускаем
                let zero = CMTime.zero
                self.player.seek(to: zero, toleranceBefore: .zero, toleranceAfter: .zero) { _ in
                    self.player.playImmediately(atRate: 1.0)
                    self.isPlaying = true
                }
            }
            .store(in: &itemCancellables)

        // На случай внешних стопов
        NotificationCenter.default.publisher(for: .AVPlayerItemPlaybackStalled, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self, !self.userPaused else { return }
                self.player.playImmediately(atRate: 1.0)
                self.isPlaying = true
            }
            .store(in: &itemCancellables)
    }

    private func attachDiagnosticsIfNeeded() {
        guard timeObserver == nil else { return }
        timeObserver = player.addPeriodicTimeObserver(
            forInterval: CMTime(seconds: 0.5, preferredTimescale: 600),
            queue: .main
        ) { [weak self] t in
            guard let self else { return }
            let status: String
            switch self.player.timeControlStatus {
            case .paused: status = "paused"
            case .waitingToPlayAtSpecifiedRate: status = "waiting"
            case .playing: status = "playing"
            @unknown default: status = "unknown"
            }
            let reason = self.player.reasonForWaitingToPlay?.rawValue ?? "nil"
            debugPrint(String(format: "⏱ %.2f s, status=%@, reason=%@", t.seconds, status, reason))
        }
    }
}
// App/App.swift
import SwiftUI

@main
struct DemoApp: App {
    var body: some Scene {
        WindowGroup {
            NavigationStack {
                // Вариант для быстрой проверки гипотезы:
                // nil → автоматически найдём и запустим первый полностью открытый ролик
                //SingleVideoView(videoID: nil)
                ReelsView()
                // или, если хочешь принудительно:
                // SingleVideoView(videoID: 52)
            }
        }
    }
}
//
//  ReelDistanceKey.swift
//  HLSDemo
//
//  Created by Niiaz Khasanov on 10/17/25.
//


import SwiftUI

// PreferenceKey для передачи расстояния карточек до центра экрана
private struct ReelDistanceKey: PreferenceKey {
    static var defaultValue: [Int: CGFloat] = [:]
    static func reduce(value: inout [Int : CGFloat], nextValue: () -> [Int : CGFloat]) {
        value.merge(nextValue(), uniquingKeysWith: { $1 })
    }
}
import SwiftUI
import AVFAudio

struct ReelsView: View {
    @StateObject private var vm = ReelsViewModel()

    var body: some View {
        ReelsPagerRepresentable(
            items: vm.items,
            activeID: vm.activeVideoID,
            player: vm.player,
            onActiveIndexChanged: { index in
                guard index >= 0, index < vm.items.count else { return }
                let id = vm.items[index].video_id
                vm.setActive(videoID: id, mute: true)   // сразу переключаем плеер
            }
        )
        .ignoresSafeArea()
        .background(Color.black)
        .task {
            configureAudioSessionForPlayback()
            await vm.load()
        }
        .navigationTitle("Reels")
    }
}


// App/Infrastructure/Repositories/VideoRepository.swift
import Foundation

public protocol VideoRepository {
    func fetchRecommendations(offset: Int, limit: Int) async throws -> [VideoRecommendation]
}

public final class DefaultVideoRepository: VideoRepository {
    private let client: HTTPClient
    public init(client: HTTPClient) { self.client = client }

    private struct RecResponse: Decodable {
        let items: [VideoRecommendation]
    }

    public func fetchRecommendations(offset: Int, limit: Int) async throws -> [VideoRecommendation] {
        let url = InteresnoAPI.recommendationsURL(offset: offset, limit: limit)
        let (data, http) = try await client.get(url: url)
        guard (200..<300).contains(http.statusCode) else { throw URLError(.badServerResponse) }
        return try JSONDecoder().decode(RecResponse.self, from: data).items
    }
}
// App/Core/Networking/HTTPClient.swift
import Foundation

public protocol HTTPClient {
    func get(url: URL) async throws -> (Data, HTTPURLResponse)
}

public final class DefaultHTTPClient: HTTPClient {
    private let session: URLSession
    public init(session: URLSession = .shared) { self.session = session }

    public func get(url: URL) async throws -> (Data, HTTPURLResponse) {
        let (data, resp) = try await session.data(from: url)
        guard let http = resp as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        return (data, http)
    }
}
import Foundation
import Combine
import AVFoundation

@MainActor
final class ReelsViewModel: ObservableObject {
    @Published var items: [VideoRecommendation] = []
    @Published var activeVideoID: Int?

    // общий плеер
    let player = AVPlayer()

    private let repo: VideoRepository = DefaultVideoRepository(client: DefaultHTTPClient())
    private var itemCancellables = Set<AnyCancellable>()
    private var timeObserver: Any?
    private var lastPlayedID: Int?

    deinit {
        if let obs = timeObserver { player.removeTimeObserver(obs) }
        NotificationCenter.default.removeObserver(self)
        itemCancellables.removeAll()
    }

    // Загружаем ленту
    func load() async {
        do {
            let recs = try await repo.fetchRecommendations(offset: 0, limit: 30)
            self.items = recs
            if let first = recs.first {
                setActive(videoID: first.video_id)
            }
        } catch {
            print("reels load error:", error)
        }
    }

    // Установка активного клипа
    func setActive(videoID: Int, mute: Bool = true) {
        guard activeVideoID != videoID else { return }
        activeVideoID = videoID
        play(videoID: videoID, mute: mute)
    }

    // Проиграть конкретный id в общем плеере (с автоплеем и репитом)
    func play(videoID: Int, mute: Bool = true) {
        guard lastPlayedID != videoID else { return }         // важное: не пересоздаём тот же item
        lastPlayedID = videoID

        let url   = InteresnoAPI.hlsPlaylistURL(videoID: videoID)
        let asset = AVURLAsset(url: url)
        let item  = AVPlayerItem(asset: asset)

        // буфер/битрейт
        player.automaticallyWaitsToMinimizeStalling = false
        item.preferredForwardBufferDuration = 0.8

        player.replaceCurrentItem(with: item)                 // старое видео автоматически останавливается
        player.currentItem?.preferredPeakBitRate = 1_200_000
        player.preventsDisplaySleepDuringVideoPlayback = true
        player.allowsExternalPlayback = false
        player.isMuted = mute

        // первая попытка — если рано, Combine добьёт
        player.playImmediately(atRate: 1.0)

        attachItemAutoplayObservers(for: item)
        attachDiagnosticsIfNeeded()
        attachLoop(for: item)
    }

    // Репит через seek к нулю
    private func attachLoop(for item: AVPlayerItem) {
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else { return }
                self.player.seek(to: .zero, toleranceBefore: .zero, toleranceAfter: .zero) { _ in
                    self.player.playImmediately(atRate: 1.0)
                }
            }
            .store(in: &itemCancellables)
    }

    // Автоплей — Combine вместо KVO
    private func attachItemAutoplayObservers(for item: AVPlayerItem) {
        itemCancellables.removeAll()

        item.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                guard let self else { return }
                if status == .readyToPlay {
                    self.player.playImmediately(atRate: 1.0)
                }
            }
            .store(in: &itemCancellables)

        item.publisher(for: \.isPlaybackLikelyToKeepUp)
            .removeDuplicates()
            .receive(on: RunLoop.main)
            .sink { [weak self] keepUp in
                guard let self, keepUp else { return }
                self.player.playImmediately(atRate: 1.0)
            }
            .store(in: &itemCancellables)

        NotificationCenter.default.publisher(for: .AVPlayerItemPlaybackStalled, object: item)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                self?.player.playImmediately(atRate: 1.0)
            }
            .store(in: &itemCancellables)
    }

    // Диагностика (опционально)
    private func attachDiagnosticsIfNeeded() {
        guard timeObserver == nil else { return }
        timeObserver = player.addPeriodicTimeObserver(
            forInterval: CMTime(seconds: 0.5, preferredTimescale: 600),
            queue: .main
        ) { [weak self] t in
            guard let self else { return }
            let status: String
            switch self.player.timeControlStatus {
            case .paused: status = "paused"
            case .waitingToPlayAtSpecifiedRate: status = "waiting"
            case .playing: status = "playing"
            @unknown default: status = "unknown"
            }
            let reason = self.player.reasonForWaitingToPlay?.rawValue ?? "nil"
            debugPrint(String(format: "reels ⏱ %.2f s, status=%@, reason=%@", t.seconds, status, reason))
        }
    }
}
import SwiftUI
import UIKit
import AVFoundation

// MARK: - Snapping FlowLayout (центрирование элемента)
final class SnappingFlowLayout: UICollectionViewFlowLayout {
    override func targetContentOffset(forProposedContentOffset proposed: CGPoint,
                                      withScrollingVelocity velocity: CGPoint) -> CGPoint {
        guard let cv = collectionView else { return super.targetContentOffset(forProposedContentOffset: proposed) }
        let bounds = cv.bounds
        let midY   = proposed.y + bounds.size.height / 2.0

        guard let attrs = layoutAttributesForElements(in: CGRect(x: 0, y: proposed.y, width: bounds.width, height: bounds.height))
        else { return super.targetContentOffset(forProposedContentOffset: proposed) }

        var closest: UICollectionViewLayoutAttributes?
        var minDist = CGFloat.greatestFiniteMagnitude
        for a in attrs where a.representedElementCategory == .cell {
            let dist = abs(a.center.y - midY)
            if dist < minDist {
                minDist = dist
                closest = a
            }
        }
        guard let target = closest else { return super.targetContentOffset(forProposedContentOffset: proposed) }
        let newOffsetY = target.center.y - bounds.size.height / 2.0
        return CGPoint(x: proposed.x, y: newOffsetY)
    }
}

// MARK: - Cell
final class ReelCell: UICollectionViewCell {
    static let reuseID = "ReelCell"

    private let preview = UIImageView()
    private let titleLabel = UILabel()
    private var playerLayer: AVPlayerLayer?

    override init(frame: CGRect) {
        super.init(frame: frame)
        contentView.clipsToBounds = true
        contentView.layer.cornerRadius = 16

        preview.contentMode = .scaleAspectFill
        preview.clipsToBounds = true
        preview.backgroundColor = .black
        preview.translatesAutoresizingMaskIntoConstraints = false

        titleLabel.textColor = .white
        titleLabel.font = .boldSystemFont(ofSize: 18)
        titleLabel.numberOfLines = 2
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        titleLabel.layer.shadowColor = UIColor.black.cgColor
        titleLabel.layer.shadowOpacity = 0.6
        titleLabel.layer.shadowRadius = 3

        contentView.addSubview(preview)
        contentView.addSubview(titleLabel)

        NSLayoutConstraint.activate([
            preview.topAnchor.constraint(equalTo: contentView.topAnchor),
            preview.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            preview.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            preview.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),

            titleLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 16),
            titleLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -16),
            titleLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -24)
        ])

        contentView.layer.borderColor = UIColor(white: 1, alpha: 0.08).cgColor
        contentView.layer.borderWidth = 1
        backgroundColor = .black
    }

    required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    override func prepareForReuse() {
        super.prepareForReuse()
        detachPlayer()
        preview.image = nil
        titleLabel.text = nil
    }

    func configure(title: String, previewURL: URL?, showPlayer: Bool, sharedPlayer: AVPlayer) {
        titleLabel.text = title
        if showPlayer {
            attachPlayer(player: sharedPlayer)
        } else {
            detachPlayer()
        }
        if let url = previewURL {
            loadPreview(from: url)
        } else {
            preview.backgroundColor = .black
        }
    }

    private func attachPlayer(player: AVPlayer) {
        if playerLayer?.player !== player {
            detachPlayer()
            let layer = AVPlayerLayer(player: player)
            layer.videoGravity = .resizeAspectFill
            layer.frame = contentView.bounds
            contentView.layer.insertSublayer(layer, above: preview.layer)
            playerLayer = layer
        }
        playerLayer?.frame = contentView.bounds
    }

    private func detachPlayer() {
        playerLayer?.player = nil
        playerLayer?.removeFromSuperlayer()
        playerLayer = nil
    }

    override func layoutSubviews() {
        super.layoutSubviews()
        playerLayer?.frame = contentView.bounds
    }

    private func loadPreview(from url: URL) {
        let req = URLRequest(url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: 15)
        if let cached = URLCache.shared.cachedResponse(for: req)?.data, let img = UIImage(data: cached) {
            self.preview.image = img
            return
        }
        URLSession.shared.dataTask(with: req) { data, resp, _ in
            guard let d = data, let img = UIImage(data: d) else { return }
            if let resp { URLCache.shared.storeCachedResponse(CachedURLResponse(response: resp, data: d), for: req) }
            DispatchQueue.main.async { [weak self] in self?.preview.image = img }
        }.resume()
    }
}

// MARK: - ViewController + Representable
final class ReelsPagerViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate {
    private let layout = SnappingFlowLayout()
    private var collectionView: UICollectionView!
    private var items: [VideoRecommendation] = []
    private var activeID: Int?
    private var horizontalPadding: CGFloat = 24     // чуть меньше карточка
    private var verticalPadding: CGFloat = 24

    // контроль обновлений
    private var didSetInitial = false
    private var lastItemsSignature: String?

    // внешние зависимости
    var onActiveIndexChanged: ((Int) -> Void)?
    var sharedPlayer: AVPlayer!

    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .black

        layout.scrollDirection = .vertical
        layout.minimumLineSpacing = 16
        layout.sectionInset = .init(top: verticalPadding, left: horizontalPadding, bottom: verticalPadding, right: horizontalPadding)

        collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
        collectionView.translatesAutoresizingMaskIntoConstraints = false
        collectionView.backgroundColor = .black
        collectionView.decelerationRate = .fast       // для резкого снапа
        collectionView.showsVerticalScrollIndicator = false
        collectionView.register(ReelCell.self, forCellWithReuseIdentifier: ReelCell.reuseID)
        collectionView.dataSource = self
        collectionView.delegate = self

        view.addSubview(collectionView)
        NSLayoutConstraint.activate([
            collectionView.topAnchor.constraint(equalTo: view.topAnchor),
            collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        let w = view.bounds.width - 2 * horizontalPadding
        let h = view.bounds.height - 2 * verticalPadding
        layout.itemSize = CGSize(width: w, height: h)
        layout.invalidateLayout()
    }

    // обновляем только если реально изменился набор
    func setItems(_ newItems: [VideoRecommendation]) {
        let sig = newItems.map { "\($0.video_id)" }.joined(separator: ",")
        guard sig != lastItemsSignature else { return }
        lastItemsSignature = sig

        self.items = newItems
        collectionView?.reloadData()

        // выставим активный 0 только один раз
        if !didSetInitial, !newItems.isEmpty {
            didSetInitial = true
            DispatchQueue.main.async { [weak self] in
                guard let self else { return }
                self.scrollTo(index: 0, animated: false)
                self.notifyActive(index: 0)
            }
        }
    }

    func setActiveVideoID(_ id: Int?) {
        self.activeID = id
        // обновить только видимые
        for cell in collectionView.visibleCells {
            guard let idx = collectionView.indexPath(for: cell)?.item else { continue }
            let item = items[idx]
            let showPlayer = (item.video_id == id)
            (cell as? ReelCell)?.configure(
                title: item.title,
                previewURL: URL(string: item.preview_image ?? ""),
                showPlayer: showPlayer,
                sharedPlayer: sharedPlayer
            )
        }
    }

    private func scrollTo(index: Int, animated: Bool) {
        guard index >= 0, index < items.count else { return }
        collectionView.scrollToItem(at: IndexPath(item: index, section: 0), at: .centeredVertically, animated: animated)
    }

    private func notifyActive(index: Int) {
        onActiveIndexChanged?(index)
    }

    // MARK: - DataSource
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { items.count }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ReelCell.reuseID, for: indexPath) as! ReelCell
        let item = items[indexPath.item]
        let showPlayer = (item.video_id == activeID)
        cell.configure(
            title: item.title,
            previewURL: URL(string: item.preview_image ?? ""),
            showPlayer: showPlayer,
            sharedPlayer: sharedPlayer
        )
        return cell
    }

    // MARK: - Delegate (агрессивный снап на лёгкий свайп)
    func scrollViewWillEndDragging(_ scrollView: UIScrollView,
                                   withVelocity velocity: CGPoint,
                                   targetContentOffset: UnsafeMutablePointer<CGPoint>) {
        guard !items.isEmpty else { return }

        // текущий центр
        let midY = scrollView.contentOffset.y + scrollView.bounds.height / 2
        // ближайшая к центру сейчас
        let visible = collectionView.indexPathsForVisibleItems
        let currentIndex: Int = {
            let target = visible.min { lhs, rhs in
                let f1 = collectionView.layoutAttributesForItem(at: lhs)?.frame ?? .zero
                let f2 = collectionView.layoutAttributesForItem(at: rhs)?.frame ?? .zero
                let d1 = abs(f1.midY - midY)
                let d2 = abs(f2.midY - midY)
                return d1 < d2
            }
            return target?.item ?? 0
        }()

        // решаем, куда листнуть:
        // - если есть ощутимая скорость — на соседнюю в направлении
        // - иначе, по смещению от идеального центра больше порога
        let threshold: CGFloat = 10 // достаточно «чуть-чуть»
        var targetIndex = currentIndex

        if abs(velocity.y) > 0.1 {
            targetIndex = currentIndex + (velocity.y > 0 ? 1 : -1)
        } else {
            if let curFrame = collectionView.layoutAttributesForItem(at: IndexPath(item: currentIndex, section: 0))?.frame {
                let delta = curFrame.midY - midY
                if delta < -threshold { targetIndex = min(currentIndex + 1, items.count - 1) }
                else if delta > threshold { targetIndex = max(currentIndex - 1, 0) }
            }
        }
        targetIndex = max(0, min(items.count - 1, targetIndex))

        // вычислим центр целевой карточки
        if let attr = collectionView.layoutAttributesForItem(at: IndexPath(item: targetIndex, section: 0)) {
            let newOffsetY = attr.center.y - scrollView.bounds.height / 2
            targetContentOffset.pointee = CGPoint(x: targetContentOffset.pointee.x, y: newOffsetY)
            // заранее сообщим активный — так быстрее запустится видео
            notifyActive(index: targetIndex)
        }
    }

    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        centerSnapAndActivate()
    }

    func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
        if !decelerate { centerSnapAndActivate() }
    }

    private func centerSnapAndActivate() {
        let center = CGPoint(x: collectionView.bounds.midX,
                             y: collectionView.contentOffset.y + collectionView.bounds.midY)
        if let indexPath = collectionView.indexPathForItem(at: center) {
            notifyActive(index: indexPath.item)
        }
    }
}

// MARK: - SwiftUI wrapper
struct ReelsPagerRepresentable: UIViewControllerRepresentable {
    let items: [VideoRecommendation]
    let activeID: Int?
    let player: AVPlayer
    let onActiveIndexChanged: (Int) -> Void

    func makeUIViewController(context: Context) -> ReelsPagerViewController {
        let vc = ReelsPagerViewController()
        vc.sharedPlayer = player
        vc.onActiveIndexChanged = onActiveIndexChanged
        return vc
    }

    func updateUIViewController(_ ui: ReelsPagerViewController, context: Context) {
        ui.sharedPlayer = player
        ui.setItems(items)               // обновим только если реально поменялись
        ui.setActiveVideoID(activeID)    // пересоберём видимые, чтобы player был только в активной
    }
}
import SwiftUI
import AVKit
import AVFAudio

final class AutoplayPlayerViewController: AVPlayerViewController {
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        // На экране? Ещё раз дожмём автоплей.
        player?.playImmediately(atRate: 1.0)
    }
}

struct PlayerViewRepresentable: UIViewControllerRepresentable {
    let player: AVPlayer
    var showsControls: Bool = true
    var fill: Bool = true

    func makeUIViewController(context: Context) -> AVPlayerViewController {
        let vc = AutoplayPlayerViewController()
        vc.player = player
        vc.showsPlaybackControls = showsControls
        vc.videoGravity = fill ? .resizeAspectFill : .resizeAspect
        vc.allowsPictureInPicturePlayback = true
        vc.canStartPictureInPictureAutomaticallyFromInline = true
        vc.updatesNowPlayingInfoCenter = false
        return vc
    }

    func updateUIViewController(_ ui: AVPlayerViewController, context: Context) {
        if ui.player !== player { ui.player = player }
    }
}

func configureAudioSessionForPlayback() {
    do {
        try AVAudioSession.sharedInstance().setCategory(.playback, mode: .moviePlayback, options: [.mixWithOthers])
        try AVAudioSession.sharedInstance().setActive(true)
    } catch {
        print("AudioSession error:", error)
    }
}
// App/Infrastructure/API/InteresnoAPI.swift
import Foundation

public enum InteresnoAPI {
    public static let base = URL(string: "https://interesnoitochka.ru/api/v1")!

    public static func hlsPlaylistURL(videoID: Int) -> URL {
        base.appendingPathComponent("videos/video/\(videoID)/hls/playlist.m3u8")
    }

    public static func recommendationsURL(offset: Int = 0, limit: Int = 20) -> URL {
        var comps = URLComponents(url: base.appendingPathComponent("videos/recommendations"),
                                  resolvingAgainstBaseURL: false)!
        comps.queryItems = [
            .init(name: "offset", value: String(offset)),
            .init(name: "limit", value: String(limit)),
            .init(name: "category", value: "shorts"),
            .init(name: "date_filter_type", value: "created"),
            .init(name: "sort_by", value: "date_created"),
            .init(name: "sort_order", value: "desc")
        ]
        return comps.url!
    }
}
//
//  ReelCardView.swift
//  HLSDemo
//
//  Created by Niiaz Khasanov on 10/17/25.
//


import SwiftUI
import AVFoundation

/// Одна карточка «рила». Если активна — показывает общий плеер; иначе — превью-картинку.
struct ReelCardView: View {
    let item: VideoRecommendation
    let isActive: Bool
    let player: AVPlayer

    var body: some View {
        ZStack {
            if isActive {
                PlayerViewRepresentable(player: player, showsControls: true, fill: true)
                    .id("player-\(item.video_id)") // стабильность обновлений
            } else {
                if let urlStr = item.preview_image, let url = URL(string: urlStr) {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .success(let image):
                            image.resizable().scaledToFill()
                        case .failure(_):
                            placeholder
                        case .empty:
                            Color.black.opacity(0.6)
                        @unknown default:
                            Color.black.opacity(0.6)
                        }
                    }
                } else {
                    placeholder
                }
            }

            // заголовок/оверлей
            VStack {
                Spacer()
                HStack {
                    Text(item.title)
                        .font(.headline)
                        .foregroundStyle(.white)
                        .lineLimit(2)
                        .shadow(radius: 3)
                    Spacer()
                }
                .padding(.horizontal, 16)
                .padding(.bottom, 24)
            }
        }
        .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
        .contentShape(Rectangle())
        .background(Color.black.opacity(0.9))
        .overlay(
            RoundedRectangle(cornerRadius: 16).stroke(Color.white.opacity(0.08), lineWidth: 1)
        )
    }

    private var placeholder: some View {
        ZStack {
            Color.black
            Text("Превью недоступно")
                .foregroundStyle(.white.opacity(0.6))
                .font(.subheadline)
        }
    }
}
